{
  "version": 3,
  "sources": ["../../../../src/cubing/search/inside/solve/puzzles/2x2x2.ts", "../../../../src/cubing/search/inside/solve/tremble.ts", "../../../../src/cubing/search/inside/solve/twsearch.ts", "../../../../src/cubing/search/inside/solve/puzzles/dynamic/sgs-side-events/index.ts", "../../../../src/cubing/search/inside/solve/puzzles/dynamic/4x4x4/index.ts", "../../../../src/cubing/search/inside/solve/puzzles/4x4x4.ts", "../../../../src/cubing/search/inside/solve/puzzles/dynamic/fto/index.ts", "../../../../src/cubing/search/inside/solve/puzzles/fto.ts", "../../../../src/cubing/search/inside/solve/puzzles/dynamic/kilominx/index.ts", "../../../../src/cubing/search/inside/solve/puzzles/kilominx.ts", "../../../../src/cubing/search/inside/solve/puzzles/dynamic/master_tetraminx/index.ts", "../../../../src/cubing/search/inside/solve/puzzles/master_tetraminx.ts", "../../../../src/cubing/search/inside/solve/puzzles/megaminx.ts", "../../../../src/cubing/search/inside/solve/puzzles/pyraminx.ts", "../../../../src/cubing/search/inside/solve/puzzles/dynamic/sgs-unofficial/index.ts", "../../../../src/cubing/search/inside/solve/puzzles/redi_cube.ts", "../../../../src/cubing/search/inside/solve/puzzles/skewb.ts", "../../../../src/cubing/search/inside/api.ts", "../../../../src/cubing/search/inside/index.ts"],
  "sourcesContent": ["import { randomPermuteInPlace, randomUIntBelow } from \"random-uint-below\";\nimport type { Alg } from \"../../../../alg\";\nimport type { KPuzzle } from \"../../../../kpuzzle\";\nimport { KPattern } from \"../../../../kpuzzle\";\nimport { cube2x2x2, puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { wasmTwsearch } from \"../twsearch\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgsCachedData: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedData222();\n      return new TrembleSolver(\n        await puzzles[\"2x2x2\"].kpuzzle(),\n        sgsCachedData,\n        \"URFLBD\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitialize222(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: fix def consistency.\nexport async function solve222(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  return wasmTwsearch((await cube2x2x2.kpuzzle()).definition, pattern, {\n    generatorMoves: \"UFLR\".split(\"\"),\n  });\n}\n\n// TODO: factor out and test.\nfunction mutatingRandomizeOrbit(\n  kpuzzle: KPuzzle,\n  orbitName: string,\n  pattern: KPattern,\n  options?: { orientationSum?: number },\n): void {\n  randomPermuteInPlace(pattern.patternData[orbitName].pieces);\n\n  const orbitDefinition = kpuzzle.lookupOrbitDefinition(orbitName);\n  const ori = pattern.patternData[orbitName].orientation;\n\n  let sum = 0;\n  for (let i = 0; i < orbitDefinition.numPieces; i++) {\n    const o = randomUIntBelow(orbitDefinition.numOrientations);\n    ori[i] = o;\n    sum += o;\n  }\n\n  // console.log(\"aaaa\", options && \"orientationSum\" in options);\n  if (options && \"orientationSum\" in options) {\n    // console.log(\"sfdsf\", options!.orientationSum),\n    ori[0] =\n      (((ori[0] + options.orientationSum! - sum) %\n        orbitDefinition.numOrientations) +\n        orbitDefinition.numOrientations) %\n      orbitDefinition.numOrientations;\n  }\n}\n\n// TODO: Use SGS?\nexport async function random222Pattern(): Promise<KPattern> {\n  const kpuzzle = await puzzles[\"2x2x2\"].kpuzzle();\n  const patternCopy: KPattern = new KPattern(\n    kpuzzle,\n    structuredClone(kpuzzle.defaultPattern().patternData),\n  ); // TODO\n  mutatingRandomizeOrbit(kpuzzle, \"CORNERS\", patternCopy, {\n    orientationSum: 0,\n  });\n  return patternCopy;\n}\n", "import { randomChoice } from \"random-uint-below\";\nimport { Alg, AlgBuilder, Move, type QuantumMove } from \"../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../kpuzzle\";\nimport type { KPattern } from \"../../../kpuzzle/KPattern\";\nimport { experimentalCountMoves } from \"../../../notation\";\nimport type { SGSCachedData } from \"./parseSGS\";\n\nconst DEFAULT_STAGE1_DEPTH_LIMIT = 2; // Moderately performant default.\n\nconst DOUBLECHECK_PLACED_PIECES = true;\nconst DEBUG = false;\n\n// TODO: Take moves instead of move names?\nfunction calculateMoves(\n  kpuzzle: KPuzzle,\n  moveNames: string[],\n): {\n  move: Move;\n  transformation: KTransformation;\n}[] {\n  const searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[] = [];\n  // const identity = identityTransformation(def); // TODO\n  // TODO: Make it easy to filter moves.\n  for (const moveName of moveNames) {\n    const rootMove = new Move(moveName);\n    if (rootMove.amount !== 1) {\n      throw new Error(\n        \"SGS cannot handle def moves with an amount other than 1 yet.\",\n      );\n    }\n    let transformation = kpuzzle.identityTransformation();\n    for (let i = 1; ; i++) {\n      transformation = transformation.applyMove(rootMove);\n      if (transformation.isIdentityTransformation()) {\n        break;\n      }\n      searchMoves.push({\n        move: rootMove.modified({ amount: i }),\n        transformation,\n      });\n    }\n  }\n  return searchMoves;\n}\n\n// function badRandomMoves(moves: string[], ksp: KSolvePuzzle): KSolvePuzzleState {\n//   // var sum = 0;\n//   var scramble = \"\";\n//   for (var i = 0; i < 1000; i++) {\n//     scramble = scramble + \" \" + moves[Math.floor(moves.length * Math.random())];\n//   }\n//   // var sol = \"\";\n//   const indexer = new TreeAlgIndexer(ksp, Alg.fromString(scramble));\n//   return indexer.transformAtIndex(indexer.numMoves()) as any; // TODO\n// }\n\nexport class TrembleSolver {\n  private searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[];\n\n  constructor(\n    private kpuzzle: KPuzzle,\n    private sgs: SGSCachedData,\n    trembleMoveNames?: string[],\n  ) {\n    this.searchMoves = calculateMoves(\n      this.kpuzzle,\n      trembleMoveNames ?? Object.keys(this.kpuzzle.definition.moves),\n    );\n  }\n\n  // public badRandomMoves(): KSolvePuzzleState {\n  //   return badRandomMoves(this.moves, this.ksp);\n  // }\n\n  public async solve(\n    pattern: KPattern,\n    stage1DepthLimit: number = DEFAULT_STAGE1_DEPTH_LIMIT,\n    quantumMoveOrder?: (quantumMove: QuantumMove) => number,\n  ): Promise<Alg> {\n    const transformation = pattern.experimentalToTransformation();\n    if (!transformation) {\n      throw new Error(\n        \"distinguishable pieces are not supported in tremble solver yt\",\n      );\n    }\n    let bestAlg: Alg | null = null;\n    let bestLen = 1000000;\n    const recur = (\n      recursiveTransformation: KTransformation, // TODO: Support KStatq1\n      togo: number,\n      sofar: Alg,\n    ) => {\n      // console.log(\"recur\");\n      if (togo === 0) {\n        const sgsAlg = this.sgsPhaseSolve(recursiveTransformation, bestLen);\n        if (!sgsAlg) {\n          return;\n        }\n        // console.log(\"sgs done!\", sofar.toString(), \"|\", sgsAlg.toString());\n        const newAlg = sofar.concat(sgsAlg).experimentalSimplify({\n          cancel: {\n            directional: \"any-direction\",\n            puzzleSpecificModWrap: \"canonical-centered\",\n          },\n          puzzleSpecificSimplifyOptions: { quantumMoveOrder },\n        });\n\n        const len = experimentalCountMoves(newAlg);\n        if (bestAlg === null || len < bestLen) {\n          if (DEBUG) {\n            console.log(`New best (${len} moves): ${newAlg.toString()}`);\n            console.log(`Tremble moves are: ${sofar.toString()}`);\n          }\n          bestAlg = newAlg;\n          bestLen = len;\n        }\n        return;\n      }\n      for (const searchMove of this.searchMoves) {\n        recur(\n          recursiveTransformation.applyTransformation(\n            searchMove.transformation,\n          ),\n          togo - 1,\n          sofar.concat([searchMove.move]),\n        );\n      }\n    };\n    for (let d = 0; d <= stage1DepthLimit; d++) {\n      recur(transformation, d, new Alg());\n    }\n    if (bestAlg === null) {\n      throw new Error(\"SGS search failed.\");\n    }\n    return bestAlg;\n  }\n\n  private sgsPhaseSolve(\n    initialTransformation: KTransformation, // TODO: Handle KPattern\n    bestLenSofar: number,\n  ): Alg | null {\n    // const pieceNames = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\n\n    // function loggo(s: string) {\n    //   // console.warn(s);\n    //   // document.body.appendChild(document.createElement(\"div\")).textContent = s;\n    // }\n\n    // console.log(\"sgsPhaseSolve\");\n    const algBuilder = new AlgBuilder();\n    let transformation = initialTransformation;\n    for (const step of this.sgs.ordering) {\n      const cubieSeq = step.pieceOrdering;\n      let key = \"\";\n      const inverseTransformation = transformation.invert();\n      for (let i = 0; i < cubieSeq.length; i++) {\n        const loc = cubieSeq[i];\n        const orbitName = loc.orbitName;\n        const idx = loc.permutationIdx;\n        key += ` ${inverseTransformation.transformationData[orbitName].permutation[idx]} ${inverseTransformation.transformationData[orbitName].orientationDelta[idx]}`;\n      }\n      // console.log(key, step.lookup);\n      const info = step.lookup[key];\n      if (!info) {\n        throw new Error(\"Missing algorithm in sgs or esgs?\");\n      }\n      algBuilder.experimentalPushAlg(info.alg);\n      if (algBuilder.experimentalNumAlgNodes() >= bestLenSofar) {\n        return null;\n      }\n      transformation = transformation.applyTransformation(info.transformation);\n      if (DOUBLECHECK_PLACED_PIECES) {\n        for (let i = 0; i < cubieSeq.length; i++) {\n          const location = cubieSeq[i];\n          const orbitName = location.orbitName;\n          const idx = location.permutationIdx;\n          if (\n            transformation.transformationData[orbitName].permutation[idx] !==\n              idx ||\n            transformation.transformationData[orbitName].orientationDelta[\n              idx\n            ] !== 0\n          ) {\n            throw new Error(\"bad SGS :-(\");\n          }\n        }\n      }\n    }\n    return algBuilder.toAlg();\n  }\n}\n\nexport function randomPatternFromSGS(\n  kpuzzle: KPuzzle,\n  sgs: SGSCachedData,\n): KPattern {\n  let transformation = kpuzzle.identityTransformation();\n  for (const step of sgs.ordering) {\n    const sgsAction = randomChoice(Object.values(step.lookup));\n    transformation = transformation.applyTransformation(\n      sgsAction.transformation,\n    );\n  }\n  return transformation.toKPattern();\n}\n", "import type { Alg } from \"../../../alg\";\nimport type {\n  KPattern,\n  KPatternData,\n  KPuzzleDefinition,\n} from \"../../../kpuzzle\";\nimport { from } from \"../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const twsearchPromise: Promise<\n  typeof import(\"../../../vendor/mpl/twsearch\")\n> = from(async () => import(\"../../../vendor/mpl/twsearch\"));\n\nexport interface TwsearchOptions {\n  // TODO: start prune depth?\n  generatorMoves?: string[];\n  targetPattern?: KPatternData;\n  minDepth?: number;\n  maxDepth?: number;\n}\n\nexport async function wasmTwsearch(\n  def: KPuzzleDefinition,\n  pattern: KPattern,\n  options?: TwsearchOptions,\n): Promise<Alg> {\n  const { wasmTwsearch } = await twsearchPromise;\n  return wasmTwsearch(def, pattern, options);\n}\n\nexport async function wasmRandomScrambleForEvent(\n  eventID: string,\n): Promise<Alg> {\n  const { wasmRandomScrambleForEvent } = await twsearchPromise;\n  return wasmRandomScrambleForEvent(eventID);\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicSideEvents = from<\n  typeof import(\"./search-dynamic-sgs-side-events\")\n>(() => import(\"./search-dynamic-sgs-side-events\"));\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamic4x4x4Solver = from<\n  typeof import(\"./search-dynamic-solve-4x4x4\")\n>(() => import(\"./search-dynamic-solve-4x4x4\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { dynamic4x4x4Solver } from \"./dynamic/4x4x4\";\n\nconst randomSuffixes = [\n  [null, \"x\", \"x2\", \"x'\", \"z\", \"z'\"],\n  [null, \"y\", \"y2\", \"y'\"],\n];\n\nexport async function initialize444(): Promise<void> {\n  return (await dynamic4x4x4Solver).initialize();\n}\n\nexport async function random444Scramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await dynamic4x4x4Solver).random444Scramble();\n}\n\nexport async function random444OrientedScramble(): Promise<Alg> {\n  return addOrientationSuffix(await random444Scramble(), randomSuffixes);\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicFTO = from<typeof import(\"./search-dynamic-solve-fto\")>(\n  () => import(\"./search-dynamic-solve-fto\"),\n);\n", "import { Alg } from \"../../../../alg\";\nimport type { KPattern } from \"../../../../kpuzzle/KPattern\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { from } from \"../../../../vendor/mit/p-lazy/p-lazy\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { dynamicFTO } from \"./dynamic/fto\";\n\nconst dynamic = from<\n  typeof import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\")\n>(() => import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\"));\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (await dynamic).sgsDataFTO();\n      return new TrembleSolver(await puzzles[\"fto\"].kpuzzle(), json, [\n        \"U\",\n        \"R\",\n        \"F\",\n        \"L\",\n        \"D\",\n        \"B\",\n        \"BR\",\n        \"BL\",\n      ]);\n    })())\n  );\n}\n\nexport async function preInitializeFTO(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveFTO(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    pattern,\n    TREMBLE_DEPTH,\n    () => 3, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomFTOScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(await (await dynamicFTO).getRandomFTOScramble());\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicKilominxSolver = from<\n  typeof import(\"./search-dynamic-solve-kilominx\")\n>(() => import(\"./search-dynamic-solve-kilominx\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicKilominxSolver } from \"./dynamic/kilominx\";\n\nexport async function randomKilominxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await dynamicKilominxSolver).getRandomKilominxScramble();\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicMasterTetraminxSolver = from<\n  typeof import(\"./search-dynamic-solve-master_tetraminx\")\n>(() => import(\"./search-dynamic-solve-master_tetraminx\"));\n", "import { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicMasterTetraminxSolver } from \"./dynamic/master_tetraminx\";\n\nexport async function randomMasterTetraminxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(\n    await (\n      await dynamicMasterTetraminxSolver\n    ).randomMasterTetraminxScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KPatternData } from \"../../../../kpuzzle\";\nimport { KPattern } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 2;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedSGSDataMegaminx();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n        json,\n        [\"U\", \"R\", \"F\", \"L\", \"BR\", \"BL\", \"FR\", \"FL\", \"DR\", \"DL\", \"B\", \"D\"],\n      );\n    })())\n  );\n}\n\nexport async function preInitializeMegaminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveMegaminx(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const patternDataWithoutMO: KPatternData = structuredClone(\n    pattern.patternData,\n  );\n  patternDataWithoutMO.CENTERS.orientation = new Array(12).fill(0);\n  const patternWithoutMO = new KPattern(\n    await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n    patternDataWithoutMO,\n  );\n  const alg = await trembleSolver.solve(\n    patternWithoutMO,\n    TREMBLE_DEPTH,\n    () => 5, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KPattern } from \"../../../../kpuzzle/KPattern\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomPatternFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataPyraminx();\n      return new TrembleSolver(\n        await puzzles.pyraminx.kpuzzle(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializePyraminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solvePyraminx(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(pattern, TREMBLE_DEPTH, () => 3); // TODO: Attach quantum move order lookup to puzzle.\n  return alg;\n}\n\nexport async function randomPyraminxPatternFixedOrientation(): Promise<KPattern> {\n  mustBeInsideWorker();\n  // Note: this sets all center orientations to 0.\n  return randomPatternFromSGS(\n    await puzzles.pyraminx.kpuzzle(),\n    await (await searchDynamicSideEvents).sgsDataPyraminxFixedOrientation(),\n  );\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicUnofficial = from<\n  typeof import(\"./search-dynamic-sgs-unofficial\")\n>(() => import(\"./search-dynamic-sgs-unofficial\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { searchDynamicUnofficial } from \"./dynamic/sgs-unofficial\";\n\nexport async function randomRediCubeScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await searchDynamicUnofficial).getRandomRediCubeScramble();\n}\n", "import type { Alg, QuantumMove } from \"../../../../alg\";\nimport { KPattern } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataSkewb();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializeSkewb(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nasync function resetCenterOrientation(pattern: KPattern): Promise<KPattern> {\n  return new KPattern(\n    await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n    {\n      CORNERS: pattern.patternData.CORNERS,\n      CENTERS: {\n        pieces: pattern.patternData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    },\n  );\n}\n\n// TODO: fix def consistency.\nexport async function solveSkewb(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    await resetCenterOrientation(pattern),\n    TREMBLE_DEPTH,\n    (quantumMove: QuantumMove) => (quantumMove.family === \"y\" ? 4 : 3), // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n", "import type { Alg } from \"../../alg\";\nimport {\n  KPattern,\n  KPuzzle,\n  type KPatternData,\n  type KPuzzleDefinition,\n} from \"../../kpuzzle\";\nimport { puzzles } from \"../../puzzles\";\nimport { setIsInsideWorker } from \"./inside-worker\";\nimport { preInitialize222, solve222 } from \"./solve/puzzles/2x2x2\";\nimport {\n  initialize333,\n  random333OrientedScramble,\n  random333Scramble,\n  solve333,\n} from \"./solve/puzzles/3x3x3\";\nimport {\n  initialize444,\n  random444OrientedScramble,\n  random444Scramble,\n} from \"./solve/puzzles/4x4x4\";\nimport { randomFTOScramble } from \"./solve/puzzles/fto\";\nimport { randomKilominxScramble } from \"./solve/puzzles/kilominx\";\nimport { randomMasterTetraminxScramble } from \"./solve/puzzles/master_tetraminx\";\nimport { solveMegaminx } from \"./solve/puzzles/megaminx\";\nimport { solvePyraminx } from \"./solve/puzzles/pyraminx\";\nimport { randomRediCubeScramble } from \"./solve/puzzles/redi_cube\";\nimport { solveSkewb } from \"./solve/puzzles/skewb\";\nimport {\n  wasmRandomScrambleForEvent,\n  wasmTwsearch,\n  type TwsearchOptions,\n} from \"./solve/twsearch\";\n\nconst IDLE_PREFETCH_TIMEOUT_MS = 1000;\n\nsetIsInsideWorker(true);\n\nlet DEBUG_MEASURE_PERF = true;\nexport function setDebugMeasurePerf(newDebugMeasurePerf: boolean): void {\n  DEBUG_MEASURE_PERF = newDebugMeasurePerf;\n}\n\nfunction now() {\n  return (typeof performance === \"undefined\" ? Date : performance).now();\n}\n\nasync function measurePerf<T>(\n  name: string,\n  f: () => T | Promise<T>,\n  options?: { isPrefetch?: boolean },\n): Promise<T> {\n  if (!DEBUG_MEASURE_PERF) {\n    return f();\n  }\n\n  const start = now();\n  const result = f();\n  if ((result as any)?.then) {\n    await result;\n  }\n  const end = now();\n  console.warn(\n    `${name}${options?.isPrefetch ? \" (prefetched)\" : \"\"}: ${Math.round(\n      end - start,\n    )}ms`,\n  );\n  return result;\n}\n\nconst prefetchPromises: Map<string, Promise<Alg>> = new Map();\n// This would just be a number, except `node` is extremely silly and returns an object instead.\n// https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\nlet queuedPrefetchTimeoutID: ReturnType<typeof setTimeout> | null = null;\n\n// This is used to ensure only one scramble is running (and measured) at a time, as interleaving scrambles within a single worker isn't supported (yet).\n// Scrambles may perform async work (e.g. loading code), and this guard this prevents unintended interleaving.\nlet scrambleActivityLock: Promise<Alg>;\n\nasync function randomScrambleForEvent(\n  eventID: string,\n  options?: { isPrefetch?: boolean },\n): Promise<Alg> {\n  return (scrambleActivityLock = (async () => {\n    await scrambleActivityLock;\n    function wasm(): Promise<Alg> {\n      return measurePerf(\n        `wasmRandomScrambleForEvent(${JSON.stringify(eventID)})`,\n        () => wasmRandomScrambleForEvent(eventID),\n        {\n          isPrefetch: options?.isPrefetch,\n        },\n      );\n    }\n\n    switch (eventID) {\n      // case \"333\":\n      case \"222\":\n        return (await wasm()).experimentalSimplify({\n          puzzleSpecificSimplifyOptions: {\n            quantumMoveOrder: () => 4,\n          },\n        });\n      // case \"444\":\n      case \"555\":\n      case \"666\":\n      case \"777\":\n      // case \"333bf\":\n      case \"333fm\":\n      // case \"333oh\":\n      // case \"clock\":\n      case \"minx\":\n      case \"pyram\":\n      case \"skewb\":\n      case \"sq1\":\n      // case \"444bf\":\n      case \"555bf\":\n      // case \"333mbf\":\n      // case \"fto\":\n      // case \"master_tetraminx\":\n      // case \"kilominx\":\n      // case \"redi_cube\":\n      case \"baby_fto\":\n        return wasm();\n      case \"333\":\n      case \"333oh\":\n      case \"333ft\":\n        return measurePerf(\"random333Scramble\", random333Scramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      case \"333bf\":\n      case \"333mbf\":\n        return measurePerf(\n          \"random333OrientedScramble\",\n          random333OrientedScramble,\n        );\n      case \"444\":\n        return measurePerf(\"random444Scramble\", random444Scramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      case \"444bf\":\n        return measurePerf(\n          \"random444OrientedScramble\",\n          random444OrientedScramble,\n        );\n      case \"fto\":\n        return measurePerf(\"randomFTOScramble\", randomFTOScramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      case \"master_tetraminx\":\n        return measurePerf(\n          \"randomMasterTetraminxScramble\",\n          randomMasterTetraminxScramble,\n        );\n      case \"kilominx\":\n        return measurePerf(\"randomKilominxScramble\", randomKilominxScramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      case \"redi_cube\":\n        return measurePerf(\"randomRediCubeScramble\", randomRediCubeScramble, {\n          isPrefetch: options?.isPrefetch,\n        });\n      default:\n        throw new Error(`unsupported event: ${eventID}`);\n    }\n  })());\n}\n\nexport enum PrefetchLevel {\n  Auto = \"auto\",\n  None = \"none\",\n  Immediate = \"immediate\",\n}\n\nlet currentPrefetchLevel = PrefetchLevel.Auto;\n\nexport const insideAPI = {\n  initialize: async (eventID: string) => {\n    switch (eventID) {\n      case \"222\":\n        return measurePerf(\"preInitialize222\", preInitialize222);\n      case \"333\":\n      case \"333oh\":\n      case \"333ft\":\n        return measurePerf(\"initialize333\", initialize333);\n      case \"444\":\n        return measurePerf(\"initialize444\", initialize444);\n      default:\n        throw new Error(`unsupported event: ${eventID}`);\n    }\n  },\n\n  setScramblePrefetchLevel(prefetchLevel: `${PrefetchLevel}`) {\n    currentPrefetchLevel = prefetchLevel as PrefetchLevel;\n  },\n\n  randomScrambleForEvent: async (eventID: string): Promise<Alg> => {\n    let promise = prefetchPromises.get(eventID);\n    if (promise) {\n      prefetchPromises.delete(eventID);\n    } else {\n      promise = randomScrambleForEvent(eventID);\n    }\n    if (currentPrefetchLevel !== PrefetchLevel.None) {\n      promise.then(() => {\n        // `queuedPrefetch` could be 0, but:\n        // > Passing an invalid ID to clearTimeout() silently does nothing; no exception is thrown.\n        // https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout#notes\n        if (queuedPrefetchTimeoutID) {\n          clearTimeout(queuedPrefetchTimeoutID);\n        }\n        queuedPrefetchTimeoutID = setTimeout(\n          () => {\n            prefetchPromises.set(\n              eventID,\n              randomScrambleForEvent(eventID, {\n                isPrefetch: true,\n              }),\n            );\n          },\n          currentPrefetchLevel === PrefetchLevel.Immediate\n            ? 0\n            : IDLE_PREFETCH_TIMEOUT_MS,\n        );\n      });\n    }\n    return promise;\n  },\n\n  randomScrambleStringForEvent: async (eventID: string): Promise<string> => {\n    return (await insideAPI.randomScrambleForEvent(eventID)).toString();\n  },\n\n  solve333ToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(await puzzles[\"3x3x3\"].kpuzzle(), patternData);\n    return (await solve333(pattern)).toString();\n  },\n\n  solve222ToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(await puzzles[\"2x2x2\"].kpuzzle(), patternData);\n    return (await solve222(pattern)).toString();\n  },\n\n  solveSkewbToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(await puzzles[\"skewb\"].kpuzzle(), patternData);\n    return (await solveSkewb(pattern)).toString();\n  },\n\n  solvePyraminxToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(\n      await puzzles[\"pyraminx\"].kpuzzle(),\n      patternData,\n    );\n    return (await solvePyraminx(pattern)).toString();\n  },\n\n  solveMegaminxToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(\n      await puzzles[\"megaminx\"].kpuzzle(),\n      patternData,\n    );\n    return (await solveMegaminx(pattern)).toString();\n  },\n\n  setDebugMeasurePerf: async (measure: boolean): Promise<void> => {\n    setDebugMeasurePerf(measure);\n  },\n\n  solveTwsearchToString: async (\n    def: KPuzzleDefinition,\n    patternData: KPatternData,\n    options?: TwsearchOptions,\n  ): Promise<string> => {\n    const kpuzzle = new KPuzzle(def);\n    const pattern = new KPattern(kpuzzle, patternData);\n    return (await wasmTwsearch(def, pattern, options)).toString();\n  },\n};\n\nexport type WorkerInsideAPI = typeof insideAPI;\n", "import { expose } from \"../../vendor/apache/comlink-everywhere/inside\";\nimport { insideAPI } from \"./api\";\n\nexpose(insideAPI);\n"],
  "mappings": "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",
  "names": ["wasmTwsearch", "wasmRandomScrambleForEvent", "cachedTrembleSolver", "getCachedTrembleSolver", "getCachedTrembleSolver", "TREMBLE_DEPTH", "cachedTrembleSolver", "getCachedTrembleSolver", "getCachedTrembleSolver", "TREMBLE_DEPTH", "TREMBLE_DEPTH", "cachedTrembleSolver", "getCachedTrembleSolver", "getCachedTrembleSolver", "TREMBLE_DEPTH"]
}
